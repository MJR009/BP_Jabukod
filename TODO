- Resolve CMake warnings
- Add a "cleanall" target to remove build dir
- Add a LICENCE file (if needed)
- REMOVE mandatory ";" after an enum
- GRAMMAR:
    - CHECK IF RULES AREN'T UNNESERALI NESTING

- text: in case of inconsistencies, inspiration was taken from actual C.g4 grammar
-- bring up interesting snippets, like the way ';' are delt with in "statement" nonterminal (this specifically was inspired by C.g4)
-- declaration needen at least for good use of foreach
-- unary minus with constant taken straight as a negative number to avoid parsing as an expression
-- unary plus feels like it is not important
-- decision was made to not allow leaading zeros with numbers
-- expression does not force an assignment -> results in dead code => should there be mandatory "assignment" nonterminal?
-- typically uninitialised global variables set to 0, local undefined -> nil does not make sense as there is no way
    to convey membership or identity, it's just value, it would need to be zero => implicit inicialization to 0 (has potential of
    obfuscation if, just, not done)
-- with enums, it is supported to terminate last item with trailing ",", it is inconsistent, not in funcitons, so it is not included
    for consistency
-- constant expressions? - optimisation or a thing of obfuscation?
-- NOP ";" ?
-- list definition is equal to the C initialiser list, since it is a constant, it should be iferable without explicit type given

- slovní popis "seznamů"

Seznamy jsou definovány implicitně za překladu. Jejich chování odovídá poli. Pro deklarování proměnné jako
seznam je třeba ji zakončit znaky []. Seznamy jsou homogenní. Podle počtu zakončujicích [] je určen počet rozměrů.
Jejich velikost je určena za překladu a nelze zadat při zápisu programu. Jsou indexovány od 0.

-- !!! How do I express IO functionality? -> Raku "spurt" and "slurp"

- List access cant't be preceeded with an expression, in C only pointer arithmetic allows this, but the principles of this projects
    obfuscation do not

-- !!! Should it be possible to define functions without body delimiters {} like in C? Some functions may be just one command and this can be parsed.

-- In the current version, functions can't return lists, there is no way to encode site p=> HOW TO ENCODE SIZE???
    With 8B number pascal style encoding wouldn't be a problem.
    Just do not and embrace the segfault. -> How do I define "do this for all items" -> What is "all items" -> How do I say "This is all."
    Null value -> int 0 -> won't work
    Pointing to dynamic memoty -> very complex

    Returning list from a function?
    How is a list stored?
    What SINGLE data point referers to an entire list?
    A start address.
    Is this an address on stack or on heap? Does it matter?
    
    Strings are lists to. Why would I mix up Pascal and C style? I can obfuscate. Characters must not be 1B.

    Pepe: "Gigabyte sem, gigabyte tam, to už dneska nikoho nezajímá."

-- StrayKw2 a 3 testují situaci, jak se to chová, když jsou za sebou tokeny, co za sebou v žádném
    kontextu nemohou být, a když to lze

-- ANTLR měl problém zparsovat INT_LITERAL a LITERAL. Pokud byly definovány oba, tak nedokázal v enumu přiřadit int
    tokenu INT_LITERAL, ale jen LITERAL. TOHLE BYLO NAVÍC NEKONZISTENTNÍ MEZI JAVOU A C++.
    Přepis na neterminál se zdál že problém vyřešil.
    -- Asi problém? Jak pak poznat, který token byl rozgenerován?
    -- Teoreticky by se mohla provést implicitní konverze.
    
-- List access po list literálu? Dává to smysl?
-- Obecně list ve výrazu? Dává vcelku smysl jenom pro přiřazení

-- !!! Bylo by lepší rozdělit statetment na vlastní pravidla (teoreticky stačí labely)

-- elseCondtion2.jk je trošku cursed

-- deadExpression projde -> je to OK? -> vytvořit pravidlo assignment
